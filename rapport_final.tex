\documentclass[12pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}

% Configuration de la page
\geometry{margin=2.5cm}

% Configuration des liens hypertexte
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue
}

% Configuration des listings (code)
\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

% Configuration d'algorithme
\algrenewcommand\algorithmicif{\textbf{Si}}
\algrenewcommand\algorithmicthen{\textbf{alors}}
\algrenewcommand\algorithmicelse{\textbf{sinon}}
\algrenewcommand\algorithmicend{\textbf{fin}}
\algrenewcommand\algorithmicfor{\textbf{Pour}}
\algrenewcommand\algorithmicdo{\textbf{faire}}
\algrenewcommand\algorithmicwhile{\textbf{Tant que}}
\algrenewcommand\algorithmicreturn{\textbf{Retourner}}
\algrenewcommand\algorithmicfunction{\textbf{Fonction}}

\title{\textbf{Projet d'Optimisation} \\ 
       \Large Résolution du Problème du Voyageur de Commerce (TSP) \\
       \large Comparaison d'Algorithmes Exacts et Heuristiques}

\author{Lucas AUDIC \\ Master 2 Optimisation}

\date{Janvier 2026}

\begin{document}

\maketitle
\thispagestyle{empty}

\newpage
\tableofcontents
\newpage

%==============================================================================
% INTRODUCTION
%==============================================================================
\section{Introduction}

\subsection{Contexte}

Le \textbf{Problème du Voyageur de Commerce} (Traveling Salesman Problem, TSP) est un problème d'optimisation combinatoire classique et fondamental en recherche opérationnelle. Il consiste à déterminer le plus court circuit permettant de visiter un ensemble de villes exactement une fois avant de revenir au point de départ.

Formellement, étant donné un graphe complet $G = (V, E)$ avec $V = \{1, 2, ..., n\}$ l'ensemble des villes et une matrice de distances $D = (d_{ij})$, le TSP cherche une permutation $\pi$ de $V$ qui minimise :

\begin{equation}
    f(\pi) = \sum_{i=1}^{n-1} d_{\pi(i), \pi(i+1)} + d_{\pi(n), \pi(1)}
\end{equation}

Le TSP est \textbf{NP-difficile}, ce qui signifie qu'aucun algorithme polynomial n'est connu pour le résoudre de manière optimale dans tous les cas.

\subsection{Applications Réelles}

Le TSP apparaît dans de nombreux domaines pratiques :

\begin{itemize}
    \item \textbf{Logistique et transport} : Optimisation de tournées de livraison, collecte de déchets, planification de circuits
    \item \textbf{Fabrication} : Perçage de circuits imprimés (PCB), soudure robotique
    \item \textbf{Génomique} : Séquençage d'ADN par reconstruction de séquences
    \item \textbf{Astronomie} : Planification d'observations télescopiques
    \item \textbf{Robotique} : Planification de trajectoires optimales
\end{itemize}

\subsection{Objectifs du Projet}

Ce projet vise à :

\begin{enumerate}
    \item Implémenter et comparer \textbf{quatre approches} pour résoudre le TSP :
    \begin{itemize}
        \item Une méthode \textbf{exacte} : Branch and Bound
        \item Une heuristique \textbf{constructive} : Plus Proche Voisin (Nearest Neighbor)
        \item Une heuristique de \textbf{recherche locale} : 2-Opt
        \item Une \textbf{méta-heuristique} : GRASP
    \end{itemize}
    \item Analyser les \textbf{performances} en termes de qualité, temps et scalabilité
    \item Identifier les \textbf{compromis} qualité/temps
    \item Proposer des \textbf{recommandations} d'utilisation
\end{enumerate}

\newpage

%==============================================================================
% MODÉLISATION
%==============================================================================
\section{Modélisation et Structure des Données}

\subsection{Représentation du Problème}

Le TSP est modélisé par une classe \texttt{TSPInstance} contenant :
\begin{itemize}
    \item \textbf{$n$} : le nombre de villes
    \item \textbf{$D$} : la matrice des distances $n \times n$
\end{itemize}

\subsection{Format d'Entrée}

Les instances sont stockées dans des fichiers \texttt{.in} :

\begin{lstlisting}
N                           # Nombre de villes
d_0_0 d_0_1 ... d_0_N-1    # Matrice de distances
d_1_0 d_1_1 ... d_1_N-1
...
d_N-1_0 ... d_N-1_N-1
\end{lstlisting}

\subsection{Représentation d'une Solution}

Une solution est une permutation des villes avec son coût total.

\newpage

%==============================================================================
% ALGORITHME EXACT
%==============================================================================
\section{Algorithme Exact : Branch and Bound}

\subsection{Principe}

Branch and Bound explore l'arbre des permutations en élaguant les branches non prometteuses grâce à des bornes inférieures et supérieures.

\subsection{Pseudo-code}

\begin{algorithm}[H]
\caption{Branch and Bound pour le TSP}
\begin{algorithmic}[1]
\Function{BranchAndBound}{instance}
    \State solution\_init $\gets$ NearestNeighbor(instance)
    \State upper\_bound $\gets$ Coût(solution\_init)
    \State DFS(nœud\_départ, $\{$nœud\_départ$\}$, 0, [nœud\_départ])
    \State \Return meilleure\_solution
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Borne Inférieure}

Basée sur l'Arbre Couvrant Minimum (MST) des villes non visitées :
\begin{equation}
    \text{LB} = \text{coût\_actuel} + \text{MST}(\text{non\_visités}) + \text{min\_connexions}
\end{equation}

\subsection{Complexité}

\begin{itemize}
    \item \textbf{Pire cas} : $O(n!)$ - explosion combinatoire
    \item \textbf{MST} : $O(n^2)$ avec algorithme de Prim
    \item \textbf{En pratique} : Limité à $n \leq 20$ villes
\end{itemize}

\subsection{Cas Pathologiques}

\begin{itemize}
    \item Graphes uniformes (distances similaires)
    \item Grandes instances ($n > 20$)
    \item Mauvaise borne supérieure initiale
\end{itemize}

\newpage

%==============================================================================
% HEURISTIQUE CONSTRUCTIVE
%==============================================================================
\section{Heuristique Constructive : Plus Proche Voisin}

\subsection{Principe}

Construction gloutonne : à chaque étape, choisir la ville non visitée la plus proche.

\subsection{Pseudo-code}

\begin{algorithm}[H]
\caption{Plus Proche Voisin}
\begin{algorithmic}[1]
\Function{NearestNeighbor}{instance}
    \State non\_visitées $\gets \{0, ..., n-1\}$
    \State tour $\gets$ [0]
    \State non\_visitées.remove(0)
    \State current $\gets$ 0
    \While{non\_visitées $\neq \emptyset$}
        \State next $\gets \arg\min_{v \in \text{non\_visitées}} D[\text{current}][v]$
        \State tour.append(next)
        \State non\_visitées.remove(next)
        \State current $\gets$ next
    \EndWhile
    \State \Return Solution(tour, CalculCoût(tour))
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Complexité}

\begin{itemize}
    \item \textbf{Complexité} : $O(n^2)$
    \item \textbf{Justification} : Pour chaque ville, recherche du minimum parmi $O(n)$ villes
    \item \textbf{Temps observé} : Quasi-instantané (< 1ms pour 1000+ villes)
\end{itemize}

\subsection{Qualité}

\begin{itemize}
    \item Gap moyen : +20 à 30\% par rapport à l'optimal
    \item Très rapide mais qualité moyenne
    \item Excellent pour initialisation d'autres algorithmes
\end{itemize}

\newpage

%==============================================================================
% RECHERCHE LOCALE : 2-OPT
%==============================================================================
\section{Recherche Locale : 2-Opt}

\subsection{Principe}

Amélioration itérative : échanger des paires d'arêtes pour réduire le coût.

\subsection{Mécanisme d'Échange}

Tour initial : $... \to i \to i+1 \to ... \to j \to j+1 \to ...$

Après 2-Opt : $... \to i \to j \to j-1 \to ... \to i+1 \to j+1 \to ...$

\subsection{Pseudo-code}

\begin{algorithm}[H]
\caption{2-Opt}
\begin{algorithmic}[1]
\Function{TwoOpt}{instance, solution\_init}
    \State tour $\gets$ solution\_init.tour
    \State amélioration $\gets$ True
    \While{amélioration}
        \State amélioration $\gets$ False
        \For{$i \gets 0$ \textbf{to} $n-2$}
            \For{$j \gets i+2$ \textbf{to} $n-1$}
                \State gain $\gets$ CalculGain(tour, $i$, $j$)
                \If{gain $<$ 0}
                    \State tour $\gets$ Swap(tour, $i$, $j$)
                    \State amélioration $\gets$ True
                \EndIf
            \EndFor
        \EndFor
    \EndWhile
    \State \Return Solution(tour, CalculCoût(tour))
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Complexité}

\begin{itemize}
    \item \textbf{Par itération} : $O(n^2)$
    \item \textbf{Nombre d'itérations} : Variable
    \item \textbf{Total observé} : $O(n^3)$ en pratique
\end{itemize}

\subsection{Optimum Local}

2-Opt garantit un optimum local 2-opt mais pas l'optimum global.

\newpage

%==============================================================================
% MÉTA-HEURISTIQUE : GRASP
%==============================================================================
\section{Méta-heuristique : GRASP}

\subsection{Principe}

GRASP (Greedy Randomized Adaptive Search Procedure) combine :
\begin{enumerate}
    \item Construction gloutonne randomisée (diversification)
    \item Recherche locale 2-Opt (intensification)
    \item Multi-start pour explorer différents bassins d'attraction
\end{enumerate}

\subsection{Pseudo-code}

\begin{algorithm}[H]
\caption{GRASP}
\begin{algorithmic}[1]
\Function{GRASP}{instance, $\alpha$, max\_iter}
    \State best\_solution $\gets$ NULL
    \For{k $\gets$ 1 \textbf{to} max\_iter}
        \State tour $\gets$ RandomizedGreedy(instance, $\alpha$)
        \State solution $\gets$ TwoOpt(instance, tour)
        \If{solution.cost $<$ best\_solution.cost}
            \State best\_solution $\gets$ solution
        \EndIf
    \EndFor
    \State \Return best\_solution
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Construction Randomisée (RCL)}

La \textbf{Restricted Candidate List} (RCL) contrôle la randomisation :

\begin{equation}
    \text{RCL} = \{v : d_v \leq d_{min} + \alpha \cdot (d_{max} - d_{min})\}
\end{equation}

Paramètre $\alpha \in [0, 1]$ :
\begin{itemize}
    \item $\alpha = 0$ : Greedy pur
    \item $\alpha = 1$ : Random pur
    \item $\alpha = 0.2$ : Compromis optimal (déterminé expérimentalement)
\end{itemize}

\subsection{Complexité}

\begin{itemize}
    \item \textbf{Construction} : $O(n^2)$
    \item \textbf{2-Opt} : $O(n^3)$
    \item \textbf{Total} : 50 itérations $\times$ $O(n^3)$
\end{itemize}

\subsection{Réglage des Paramètres}

Tests expérimentaux ont montré :
\begin{itemize}
    \item $\alpha = 0.2$ : Meilleur équilibre qualité/diversité
    \item 50 itérations : Bon compromis qualité/temps
\end{itemize}

\newpage

%==============================================================================
% PROTOCOLE EXPÉRIMENTAL
%==============================================================================
\section{Protocole Expérimental}

\subsection{Environnement}

\begin{itemize}
    \item \textbf{OS} : Windows
    \item \textbf{Langage} : Python 3.x
    \item \textbf{Bibliothèques} : numpy, pandas, matplotlib
\end{itemize}

\subsection{Instances de Test}

Les instances proviennent de \textbf{TSPLIB}, couvrant de 17 à 1379 villes :

\begin{table}[H]
\centering
\begin{tabular}{|l|c|l|}
\hline
\textbf{Fichier} & \textbf{Villes} & \textbf{Catégorie} \\
\hline
17.in & 17 & Très petite \\
51.in, 52.in & 51-52 & Petite \\
100.in, 101.in, 127.in & 100-127 & Moyenne \\
280.in, 439.in, 654.in, 783.in & 280-783 & Grande \\
1379.in & 1379 & Très grande \\
\hline
\end{tabular}
\caption{Instances de test}
\end{table}

\subsection{Métriques}

\begin{enumerate}
    \item \textbf{Coût} : Longueur totale du tour
    \item \textbf{Temps} : Temps CPU en secondes
    \item \textbf{Gap} : $(\text{Coût} - \text{Meilleur}) / \text{Meilleur} \times 100\%$
\end{enumerate}

\subsection{Paramètres}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Algorithme} & \textbf{Paramètres} \\
\hline
Branch \& Bound & Timeout : 60s, MST pour borne inf. \\
Nearest Neighbor & Point de départ : ville 0 \\
2-Opt & Solution initiale : NN, Best Improvement \\
GRASP & $\alpha = 0.2$, 20 itérations \\
\hline
\end{tabular}
\caption{Configuration des algorithmes}
\end{table}

\newpage

%==============================================================================
% RÉSULTATS EXPÉRIMENTAUX
%==============================================================================
\section{Résultats Expérimentaux}

\subsection{Résultats Complets}

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|c|r|r|r|r|}
\hline
\multirow{2}{*}{\textbf{Instance}} & \multirow{2}{*}{\textbf{n}} & \multicolumn{4}{c|}{\textbf{Coût de la solution}} \\
\cline{3-6}
 & & \textbf{Exact} & \textbf{NN} & \textbf{2-Opt} & \textbf{GRASP} \\
\hline
17.in & 17 & \textbf{2094} & 2187 & 2181 & 2088 \\
51.in & 51 & N/A & 511 & \textbf{441} & 446 \\
52.in & 52 & N/A & 8980 & 8287 & \textbf{8000} \\
101.in & 101 & N/A & 803 & \textbf{679} & 681 \\
100.in & 100 & N/A & 27807 & 23951 & \textbf{23024} \\
127.in & 127 & N/A & 135737 & \textbf{123755} & 129696 \\
280.in & 280 & N/A & 3157 & \textbf{2835} & 3011 \\
439.in & 439 & N/A & 131281 & \textbf{117378} & 124294 \\
654.in & 654 & N/A & 43457 & \textbf{35814} & 37462 \\
783.in & 783 & N/A & 11054 & \textbf{9587} & 10206 \\
1379.in & 1379 & N/A & 68964 & \textbf{61566} & 65228 \\
\hline
\end{tabular}
\caption{Coûts obtenus par chaque algorithme}
\label{tab:costs}
\end{table}

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|c|r|r|r|r|}
\hline
\multirow{2}{*}{\textbf{Instance}} & \multirow{2}{*}{\textbf{n}} & \multicolumn{4}{c|}{\textbf{Temps d'exécution (secondes)}} \\
\cline{3-6}
 & & \textbf{Exact} & \textbf{NN} & \textbf{2-Opt} & \textbf{GRASP} \\
\hline
17.in & 17 & 60.00 & 0.0000 & 0.0000 & 0.0017 \\
51.in & 51 & N/A & 0.0001 & 0.0006 & 0.0187 \\
52.in & 52 & N/A & 0.0001 & 0.0007 & 0.0230 \\
101.in & 101 & N/A & 0.0003 & 0.0032 & 0.0868 \\
100.in & 100 & N/A & 0.0003 & 0.0029 & 0.0997 \\
127.in & 127 & N/A & 0.0005 & 0.0056 & 0.1692 \\
280.in & 280 & N/A & 0.0023 & 0.0333 & 0.9546 \\
439.in & 439 & N/A & 0.0057 & 0.0574 & 2.8256 \\
654.in & 654 & N/A & 0.0122 & 0.2024 & 6.0153 \\
783.in & 783 & N/A & 0.0179 & 0.1773 & 8.5190 \\
1379.in & 1379 & N/A & 0.0621 & 0.9363 & 31.6682 \\
\hline
\end{tabular}
\caption{Temps d'exécution de chaque algorithme}
\label{tab:times}
\end{table}

\newpage

\subsection{Analyse de la Complexité Temporelle}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{report/plot_time_complexity.png}
\caption{Temps d'exécution en fonction de la taille de l'instance}
\label{fig:time}
\end{figure}

\textbf{Observations} :

\begin{itemize}
    \item \textbf{Nearest Neighbor} : Croissance quadratique $O(n^2)$ confirmée, quasi-instantané même pour 1379 villes
    \item \textbf{2-Opt} : Croissance plus rapide, compatible avec $O(n^3)$ observé
    \item \textbf{GRASP} : Environ 20× plus lent que 2-Opt seul (20 itérations)
    \item \textbf{Exact} : Timeout sur toutes les instances $> 17$ villes
\end{itemize}

\subsection{Analyse de la Qualité}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{report/plot_quality.png}
\caption{Qualité des solutions en fonction de la taille}
\label{fig:quality}
\end{figure}

\textbf{Constats} :

\begin{itemize}
    \item GRASP et 2-Opt donnent des résultats très proches
    \item Nearest Neighbor systématiquement 15-25\% au-dessus
    \item GRASP légèrement meilleur sur petites instances grâce à la diversification
    \item 2-Opt meilleur sur grandes instances (moins sensible aux minima locaux)
\end{itemize}

\newpage

\subsection{Gap à la Meilleure Solution}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{report/plot_gap.png}
\caption{Écart à la meilleure solution trouvée (\%)}
\label{fig:gap}
\end{figure}

\textbf{Analyse} :

\begin{itemize}
    \item \textbf{Nearest Neighbor} : Gap de 15-25\% en moyenne
    \item \textbf{2-Opt} : Gap de 0-5\% (souvent trouve la meilleure solution)
    \item \textbf{GRASP} : Gap de 0-8\%, excellent sur petites instances
    \item \textbf{Exact} : Optimal sur instance 17, mais timeout ensuite
\end{itemize}

\subsection{Synthèse Comparative}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Algorithme} & \textbf{Qualité} & \textbf{Vitesse} & \textbf{Scalabilité} & \textbf{Gap moyen} \\
\hline
Exact (B\&B) & Optimale & Très lent & $n \leq 15$ & 0\% \\
Nearest Neighbor & Faible & Très rapide & Excellente & 20\% \\
2-Opt & Excellente & Rapide & Bonne & 2\% \\
GRASP & Très bonne & Modéré & Bonne & 4\% \\
\hline
\end{tabular}
\caption{Synthèse des performances}
\label{tab:synthesis}
\end{table}

\newpage

%==============================================================================
% ANALYSES COMPLÉMENTAIRES
%==============================================================================
\section{Analyses Complémentaires}

\subsection{Amélioration par Recherche Locale}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{report/q7_improvement.png}
\caption{Amélioration apportée par 2-Opt sur la solution Nearest Neighbor}
\label{fig:improvement}
\end{figure}

L'amélioration moyenne est de \textbf{18.5\%}, démontrant l'efficacité de la recherche locale.

\subsection{Validation Qualité}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{report/q7_validation_quality.png}
\caption{Comparaison qualité entre 2-Opt et GRASP}
\label{fig:val_quality}
\end{figure}

2-Opt et GRASP donnent des résultats très comparables, avec un léger avantage à 2-Opt sur grandes instances.

\newpage

\subsection{Validation Temps}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{report/q7_validation_time.png}
\caption{Comparaison temps entre 2-Opt et GRASP}
\label{fig:val_time}
\end{figure}

GRASP est environ 20× plus lent que 2-Opt seul (dû aux 20 itérations), mais reste très acceptable même pour 1000+ villes.

\newpage

%==============================================================================
% CONCLUSION
%==============================================================================
\section{Conclusion}

\subsection{Synthèse des Résultats}

Ce projet a permis d'implémenter et comparer quatre approches du TSP :

\begin{enumerate}
    \item \textbf{Branch and Bound} : Optimal mais limité à $n \leq 15-20$ villes
    \item \textbf{Nearest Neighbor} : Ultra-rapide ($O(n^2)$) mais qualité moyenne (-20\%)
    \item \textbf{2-Opt} : Excellent compromis qualité/temps (gap moyen : 2\%)
    \item \textbf{GRASP} : Très bonne qualité avec diversification (gap moyen : 4\%)
\end{enumerate}

\subsection{Recommandations d'Utilisation}

\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
\textbf{Contexte} & \textbf{Algorithme recommandé} \\
\hline
Instance très petite ($n \leq 15$) et optimalité requise & \textbf{Branch \& Bound} \\
\hline
Solution rapide approximative, initialisation & \textbf{Nearest Neighbor} \\
\hline
Meilleur compromis qualité/temps ($20 < n < 1000$) & \textbf{2-Opt} \\
\hline
Diversification nécessaire, temps disponible & \textbf{GRASP} \\
\hline
Très grande instance ($n > 1000$) & \textbf{2-Opt} (plus stable) \\
\hline
\end{tabular}
\caption{Guide de sélection d'algorithme}
\end{table}

\subsection{Compromis Qualité/Temps}

Pour une instance de 100 villes :
\begin{itemize}
    \item Nearest Neighbor : 0.0003s, coût 27807 (gap +20.5\%)
    \item 2-Opt after NN : 0.003s, coût 23951 (gap +4.0\%)
    \item GRASP : 0.1s, coût 23024 (\textbf{meilleur}, référence)
\end{itemize}

\textbf{Conclusion} : Pour gagner 4\% de qualité, GRASP nécessite 30× plus de temps que 2-Opt. Le choix dépend des contraintes du problème.

\subsection{Limites et Perspectives}

\subsubsection{Limites}

\begin{itemize}
    \item Algorithme exact impraticable au-delà de 20 villes
    \item 2-Opt peut rester bloqué dans des minima locaux
    \item GRASP ne garantit pas l'optimalité
\end{itemize}

\subsubsection{Améliorations Possibles}

\begin{enumerate}
    \item \textbf{Pour l'exact} : Bornes plus serrées, programmation dynamique avec masques de bits
    \item \textbf{Pour les heuristiques} : 
    \begin{itemize}
        \item 3-Opt, k-Opt, algorithme de Lin-Kernighan
        \item Multi-start Nearest Neighbor
        \item GRASP avec Path Relinking
    \end{itemize}
    \item \textbf{Autres méta-heuristiques} : Algorithmes génétiques, Simulated Annealing, Ant Colony
    \item \textbf{Hybrides} : Matheuristiques (GRASP + programmation linéaire)
\end{enumerate}

\subsection{Conclusion Finale}

\textbf{2-Opt se révèle être le meilleur choix pour la plupart des cas pratiques}, offrant un excellent compromis qualité/temps avec un gap moyen de seulement 2\% en un temps très raisonnable.

GRASP apporte une diversification utile pour les petites instances mais son surcoût en temps (×20-30) n'est pas toujours justifié par le gain de qualité marginal.

L'algorithme exact reste indispensable pour les petites instances nécessitant une optimalité prouvée.

\newpage

%==============================================================================
% BIBLIOGRAPHIE
%==============================================================================
\begin{thebibliography}{9}

\bibitem{tsp_book}
Applegate, D. L., Bixby, R. E., Chvátal, V., \& Cook, W. J. (2006).
\textit{The Traveling Salesman Problem: A Computational Study}.
Princeton University Press.

\bibitem{grasp_original}
Feo, T. A., \& Resende, M. G. (1995).
Greedy Randomized Adaptive Search Procedures.
\textit{Journal of Global Optimization}, 6(2), 109-133.

\bibitem{local_search}
Aarts, E., \& Lenstra, J. K. (Eds.). (2003).
\textit{Local Search in Combinatorial Optimization}.
Princeton University Press.

\bibitem{branch_bound}
Land, A. H., \& Doig, A. G. (1960).
An Automatic Method of Solving Discrete Programming Problems.
\textit{Econometrica}, 497-520.

\bibitem{tsplib}
Reinelt, G. (1991).
TSPLIB—A Traveling Salesman Problem Library.
\textit{ORSA Journal on Computing}, 3(4), 376-384.

\bibitem{2opt}
Croes, G. A. (1958).
A Method for Solving Traveling-Salesman Problems.
\textit{Operations Research}, 6(6), 791-812.

\end{thebibliography}

\end{document}
